{
	"$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
	"name": "Trilogy",
	"patterns": [
		{
			"include": "#statement"
		},
		{
			"include": "#expression"
		}
	],
	"repository": {
		"statement": {
			"patterns": [
				{
					"include": "#import"
				},
				{
					"include": "#datasource-declaration"
				},
								{
					"include": "#concept-declaration"
				},
				{
					"include": "#statement-keyword"
				},
				{
					"include": "#assignment-operator"
				},
								{
					"include": "#assignment-operator"
				}
			]
		},
		"import": {
			"comment": "Import statements used to correctly mark `from`, `import`, and `as`\n",
			"patterns": [
				{
					"begin": "\\b(?<!\\.)(from)\\b(?=.+import)",
					"end": "$|(?=import)",
					"beginCaptures": {
						"1": {
							"name": "keyword.control.import.trilogy"
						}
					},
					"patterns": [
						{
							"name": "punctuation.separator.period.trilogy",
							"match": "\\.+"
						},
						{
							"include": "#expression"
						}
					]
				},
				{
					"begin": "\\b(?<!\\.)(import)\\b",
					"end": "$",
					"beginCaptures": {
						"1": {
							"name": "keyword.control.import.trilogy"
						}
					},
					"patterns": [
						{
							"name": "keyword.control.import.trilogy",
							"match": "\\b(?<!\\.)as\\b"
						},
						{
							"include": "#expression"
						}
					]
				}
			]
		},
		"assignment-operator": {
			"name": "keyword.operator.assignment.trilogy",
			"match": "(?x)\n     <<= | >>= | //= | \\*\\*=\n    | \\+= | -= | /= | @=\n    | \\*= | %= | ~= | \\^= | &= | \\|=\n    | =(?!=)\n"
		},
		"concept-declaration": {
			"name": "meta.function.trilogy",
			"patterns": [{
			"begin": "(?ix)\n  \\s*\n  \\b(auto|property|metric|key|parameter|param|const|constant|unique)\\s+\n    (?=\n    [[:alpha:]_][[:word:]]* \\s* [[:alpha:]_][[:word:]]*    )\n",
			"end": "(:|(?=[#'\"\\n]))",
			"beginCaptures": {
				"1": {
					"name": "storage.type.trilogy"
				}
			},
			"endCaptures": {
				"1": {
					"name": "punctuation.section.function.begin.trilogy"
				}
			},
			"patterns": [
				{
					"include": "#grain-def-name"
				},
				{
					"include": "#function-def-name"
				},
				{
					"include": "#parameters"
				},
				{
					"include": "#line-continuation"
				}
			]
		},{
			"begin": "(?ix)\n  \\s*\n  \\b(auto|property|metric|key|parameter|param|const|constant|unique)\\s+\n    (?=\n    <\\S+>\\.[[:alpha:]_][[:word:]]* \\s* [[:alpha:]_][[:word:]]*    )\n",
			"end": "(;)",
			"beginCaptures": {
				"1": {
					"name": "storage.type.function.trilogy"
				}
			},
			"endCaptures": {
				"1": {
					"name": "punctuation.section.function.begin.trilogy"
				}
			},
			"patterns": [
				{
					"include": "#concept-list"
				},
				{
					"include": "#grain-def-name"
				},
				{
					"include": "#function-def-name"
				},
				{
					"include": "#parameters"
				},
				{
					"include": "#line-continuation"
				}
			]
		}]
		},
		"comments": {
			"patterns": [
				{
					"begin": "#",
					"end": "\\n",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.comment.hash.trilogy"
						}
					},
					"name": "comment.line.hash.trilogy"
				},
				{
					"begin": "//",
					"end": "\\n",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.comment.double-slash.trilogy"
						}
					},
					"name": "comment.line.double-slash.trilogy"
				}
			]
		},
		"select-statement": {
			"name": "meta.function.trilogy",
			"begin": "(?x)\n  \\s*\n  (?:\\b(async) \\s+)? \\b(select)\\s+\n    (?=\n    [[:alpha:]_][[:word:]]* \\s* \\(\n    )\n",
			"end": "(;)",
			"beginCaptures": {
				"1": {
					"name": "storage.type.select.async.trilogy"
				},
				"2": {
					"name": "storage.type.select.trilogy"
				}
			},
			"endCaptures": {
				"1": {
					"name": "punctuation.section.function.begin.trilogy"
				}
			},
			"patterns": [
				{
					"include": "#function-def-name"
				},
				{
					"include": "#parameters"
				},
				{
					"include": "#line-continuation"
				}
			]
		},
		"datasource-declaration": {
			"name": "meta.function.trilogy",
			"begin": "(?x)\n  \\s*\n  (?:\\b(async) \\s+)? \\b(datasource)\\s+\n    (?=\n    [[:alpha:]_][[:word:]]* \\s* \\(\n    )\n",
			"end": "(;)",
			"beginCaptures": {
				"1": {
					"name": "storage.type.function.async.trilogy"
				},
				"2": {
					"name": "storage.type.function.trilogy"
				}
			},
			"endCaptures": {
				"1": {
					"name": "punctuation.section.function.begin.trilogy"
				}
			},
			"patterns": [
				{
					"include": "#datasource-grain-clause"
				},
				{
					"include": "#datasource-file-clause"
				},
				{
					"include": "#datasource-freshness-clause"
				},
				{
					"include": "#function-def-name"
				},
				{
					"include": "#parameters"
				},
				{
					"include": "#line-continuation"
				}
			]
		},
		"datasource-grain-clause": {
			"comment": "Grain clause in datasource declaration",
			"begin": "\\b(grain)\\b",
			"end": "(?=\\b(?:file|freshness)\\b|;)",
			"beginCaptures": {
				"1": {
					"name": "keyword.control.trilogy"
				}
			},
			"patterns": [
				{
					"include": "#expression"
				}
			]
		},
		"datasource-file-clause": {
			"comment": "File clause in datasource declaration",
			"begin": "\\b(file)\\b",
			"end": "(?=\\bfreshness\\b|;)",
			"beginCaptures": {
				"1": {
					"name": "keyword.control.trilogy"
				}
			},
			"patterns": [
				{
					"include": "#string"
				},
				{
					"include": "#expression"
				}
			]
		},
		"datasource-freshness-clause": {
			"comment": "Freshness by clause in datasource declaration",
			"begin": "\\b(freshness)\\s+(by)\\b",
			"end": "(?=;)",
			"beginCaptures": {
				"1": {
					"name": "keyword.control.trilogy"
				},
				"2": {
					"name": "keyword.control.trilogy"
				}
			},
			"patterns": [
				{
					"name": "variable.other.field.trilogy",
					"match": "\\b[[:alpha:]_][[:word:]]*\\b"
				}
			]
		},
		"bind-annotation": {
			"begin": "(->)",
			"end": "(?=:)",
			"beginCaptures": {
				"1": {
					"name": "punctuation.separator.annotation.result.trilogy"
				}
			},
			"patterns": [
				{
					"include": "#expression"
				}
			]
		},
		"statement-keyword": {
			"patterns": [
				{
					"name": "storage.type.function.trilogy",
					"match": "(?i)\\b(def)\\b"
				},
				{
					"name": "keyword.control.import.trilogy",
					"match": "(?i)\\b(?<!\\.)as\\b"
				},
				{
					"name": "keyword.control.select.trilogy",
					"match": "(?i)\\b(?<!\\.)(select)\\b"
				},
				{
					"name": "keyword.control.flow.trilogy",
					"comment": "Primary query keywords",
					"match": "(?i)\\b(?<!\\.)(from|where|having|order|limit|by)\\b"
				},
				{
					"name": "keyword.control.flow.trilogy",
					"comment": "Multi-select and merge keywords",
					"match": "(?i)\\b(?<!\\.)(merge|align|derive|rowset|with)\\b"
				},
				{
					"name": "keyword.control.flow.trilogy",
					"comment": "Persist and data operation keywords",
					"match": "(?i)\\b(?<!\\.)(persist|append|overwrite|into|copy|csv|json|parquet)\\b"
				},
				{
					"name": "keyword.control.flow.trilogy",
					"comment": "Datasource keywords",
					"match": "(?i)\\b(?<!\\.)(datasource|grain|address|query|file|freshness|complete|root|partition|incremental|state|published|unpublished)\\b"
				},
				{
					"name": "keyword.control.flow.trilogy",
					"comment": "Statement keywords",
					"match": "(?i)\\b(?<!\\.)(raw_sql|validate|mock|publish|unpublish|create|show|type|drop)\\b"
				},
				{
					"name": "keyword.control.flow.trilogy",
					"comment": "Chart keywords",
					"match": "(?i)\\b(?<!\\.)(chart|line|bar|barh|point|area|headline|donut|heatmap|boxplot|treemap|set|x_axis|y_axis|color|size|group|trellis|trellis_row|geo|annotation|hide_legend|show_title|scale_x|scale_y|linear|sqrt)\\b"
				},
				{
					"name": "keyword.control.conditional.trilogy",
					"comment": "CASE/WHEN conditional keywords",
					"match": "(?i)\\b(?<!\\.)(case|when|then|else|end)\\b"
				},
				{
					"name": "keyword.control.filter.trilogy",
					"comment": "Filter and window keywords",
					"match": "(?i)\\b(?<!\\.)(filter|over)\\b"
				},
				{
					"name": "keyword.other.order.trilogy",
					"comment": "Ordering keywords",
					"match": "(?i)\\b(?<!\\.)(asc|desc|nulls|first|last)\\b"
				},
				{
					"name": "storage.type.concept.trilogy",
					"comment": "Concept declaration types",
					"match": "(?i)\\b(?<!\\.)(key|metric|property|parameter|param|const|constant|unique)\\b"
				}
			]
		},
		"grain-def-name": {
			"patterns": [
				{
					"include": "#builtin-possible-callables"
				},
				{
					"name": "keyword.control.flow.trilogy",
					"match": "(?x)\n  \\b ([[:alpha:]_]\\w*) \\b\n"
				}
			]
		},
		"function-def-name": {
			"patterns": [
				{
					"include": "#builtin-possible-callables"
				},
				{
					"name": "entity.name.function.trilogy",
					"match": "(?x)\n  \\b ([[:alpha:]_]\\w*) \\b\n"
				}
			]
		},
		
		"parameters": {
			"name": "meta.function.parameters.trilogy",
			"begin": "(\\()",
			"end": "(\\))",
			"beginCaptures": {
				"1": {
					"name": "punctuation.definition.parameters.begin.trilogy"
				}
			},
			"endCaptures": {
				"1": {
					"name": "punctuation.definition.parameters.end.trilogy"
				}
			},
			"patterns": [
				{
					"name": "keyword.operator.positional.parameter.trilogy",
					"match": "/"
				},
				{
					"name": "keyword.operator.unpacking.parameter.trilogy",
					"match": "(\\*\\*|\\*)"
				},
				{
					"include": "#illegal-names"
				},
				{
					"include": "#parameter-with-modifier"
				},
				{
					"match": "(?x)\n  ([[:alpha:]_]\\w*)\n    \\s* (?: (,) | (?=[)#\\n=]))\n",
					"captures": {
						"1": {
							"name": "variable.parameter.function.language.trilogy"
						},
						"2": {
							"name": "punctuation.separator.parameters.trilogy"
						}
					}
				},
				{
					"include": "#comments"
				},
				{
					"include": "#annotated-parameter"
				}
			]
		},
		"parameter-with-modifier": {
			"comment": "Simple parameter with optional modifier prefix (~, ?, or ~?)",
			"match": "(?x)\n  (~\\?|~|\\?)\\s*\n  ([[:alpha:]_][[:word:]]*(?:\\.[[:alpha:]_][[:word:]]*)*)\n  \\s* (?: (,) | (?=[)#\\n]))\n",
			"captures": {
				"1": {
					"name": "keyword.operator.modifier.trilogy"
				},
				"2": {
					"name": "variable.parameter.function.language.trilogy"
				},
				"3": {
					"name": "punctuation.separator.parameters.trilogy"
				}
			}
		},
		"annotated-parameter": {
			"begin": "(?x)\n  \\b\n  ([[:alpha:]_]\\w*) \\s* (:)\n",
			"end": "(,)|(?=\\))",
			"beginCaptures": {
				"1": {
					"name": "variable.parameter.function.language.trilogy"
				},
				"2": {
					"name": "punctuation.separator.annotation.trilogy"
				}
			},
			"endCaptures": {
				"1": {
					"name": "punctuation.separator.parameters.trilogy"
				}
			},
			"patterns": [
				{
					"include": "#parameter-modifier"
				},
				{
					"include": "#expression"
				},
				{
					"name": "keyword.operator.assignment.trilogy",
					"match": "=(?!=)"
				}
			]
		},
		"parameter-modifier": {
			"comment": "Modifiers for datasource parameters (~, ?, ~?)",
			"name": "keyword.operator.modifier.trilogy",
			"match": "~\\?|~|\\?"
		},
		"expression": {
			"comment": "All valid trilogy expressions",
			"patterns": [
				{
					"include": "#expression-base"
				},
				{
					"include": "#member-access"
				},
				{
					"comment": "Tokenize identifiers to help linters",
					"match": "(?x) \\b ([[:alpha:]_]\\w*) \\b"
				}
			]
		},
		"member-access": {
			"name": "meta.member.access.trilogy",
			"begin": "(\\.)\\s*(?!\\.)",
			"end": "(?x)\n  # stop when you've just read non-whitespace followed by non-word\n  # i.e. when finished reading an identifier or function call\n  (?<=\\S)(?=\\W) |\n  # stop when seeing the start of something that's not a word,\n  # i.e. when seeing a non-identifier\n  (^|(?<=\\s))(?=[^\\\\\\w\\s]) |\n  $\n",
			"beginCaptures": {
				"1": {
					"name": "punctuation.separator.period.trilogy"
				}
			},
			"patterns": [
				{
					"include": "#function-call"
				},
				{
					"include": "#member-access-base"
				},
				{
					"include": "#member-access-attribute"
				}
			]
		},
		"member-access-attribute": {
			"comment": "Highlight attribute access in otherwise non-specialized cases.",
			"name": "meta.attribute.trilogy",
			"match": "(?x)\n  \\b ([[:alpha:]_]\\w*) \\b\n"
		},
		"member-access-base": {
			"patterns": [
				{
					"include": "#magic-names"
				},
				{
					"include": "#illegal-names"
				},
				{
					"include": "#line-continuation"
				},
				{
					"include": "#item-access"
				}
			]
		},
		"item-access": {
			"patterns": [
				{
					"name": "meta.item-access.trilogy",
					"begin": "(?x)\n  \\b(?=\n    [[:alpha:]_]\\w* \\s* \\[\n  )\n",
					"end": "(\\])",
					"endCaptures": {
						"1": {
							"name": "punctuation.definition.arguments.end.trilogy"
						}
					},
					"patterns": [
						{
							"include": "#item-name"
						},
						{
							"include": "#item-index"
						},
						{
							"include": "#expression"
						}
					]
				}
			]
		},
		"item-name": {
			"patterns": [
				{
					"include": "#builtin-functions"
				},
				{
					"name": "meta.indexed-name.trilogy",
					"match": "(?x)\n  \\b ([[:alpha:]_]\\w*) \\b\n"
				}
			]
		},
		"item-index": {
			"begin": "(\\[)",
			"end": "(?=\\])",
			"beginCaptures": {
				"1": {
					"name": "punctuation.definition.arguments.begin.trilogy"
				}
			},
			"contentName": "meta.item-access.arguments.trilogy",
			"patterns": [
				{
					"name": "punctuation.separator.slice.trilogy",
					"match": ":"
				},
				{
					"include": "#expression"
				}
			]
		},
		"function-name": {
			"patterns": [
				{
					"include": "#builtin-possible-callables"
				},
				{
					"comment": "Some color schemas support meta.function-call.generic scope",
					"name": "meta.function-call.generic.trilogy",
					"match": "(?x)\n  \\b ([[:alpha:]_]\\w*) \\b\n"
				}
			]
		},
		"builtin-possible-callables": {
			"patterns": [
				{
					"include": "#builtin-callables"
				},
				{
					"include": "#magic-names"
				}
			]
		},
		"builtin-callables": {
			"patterns": [
				{
					"include": "#illegal-names"
				},
				{
					"include": "#builtin-functions"
				},
				{
					"include": "#builtin-types"
				}
			]
		},
		"builtin-types": {
			"name": "support.type.trilogy",
			"match": "(?i)(?<!\\.)\\b(string|number|numeric|int|bigint|date|datetime|timestamp|float|bool|any|struct|list|array|map|tuple)\\b"
		},
		"builtin-functions": {
			"patterns": [
				{
					"name": "support.function.math.trilogy",
					"comment": "Mathematical functions",
					"match": "(?i)(?<!\\.)\\b(add|subtract|multiply|divide|mod|log|round|floor|ceil|abs|sqrt|random)\\b"
				},
				{
					"name": "support.function.string.trilogy",
					"comment": "String functions",
					"match": "(?i)(?<!\\.)\\b(like|ilike|upper|lower|split|strpos|substring|contains|trim|replace|regexp_extract|regexp_contains|regexp_replace|hash|concat)\\b"
				},
				{
					"name": "support.function.array.trilogy",
					"comment": "Array functions",
					"match": "(?i)(?<!\\.)\\b(array_sum|array_distinct|array_to_string|array_sort|array_transform|array_filter|generate_array|unnest|union|array_agg)\\b"
				},
				{
					"name": "support.function.map.trilogy",
					"comment": "Map functions",
					"match": "(?i)(?<!\\.)\\b(map_keys|map_values)\\b"
				},
				{
					"name": "support.function.generic.trilogy",
					"comment": "Generic functions",
					"match": "(?i)(?<!\\.)\\b(cast|coalesce|nullif|len|bool|getattr|recurse_edge)\\b"
				},
				{
					"name": "support.function.aggregate.trilogy",
					"comment": "Aggregate functions",
					"match": "(?i)(?<!\\.)\\b(count|count_distinct|sum|avg|max|min|bool_and|bool_or|any)\\b"
				},
				{
					"name": "support.function.date.trilogy",
					"comment": "Date/time functions",
					"match": "(?i)(?<!\\.)\\b(date|datetime|timestamp|second|minute|hour|day|day_name|day_of_week|week|month|month_name|quarter|year|format_time|parse_time|date_trunc|date_truncate|date_part|date_add|date_sub|date_diff|date_spine)\\b"
				},
				{
					"name": "support.function.constant.trilogy",
					"comment": "Constant functions",
					"match": "(?i)(?<!\\.)\\b(current_date|current_datetime|current_timestamp)\\b"
				},
				{
					"name": "support.function.window.trilogy",
					"comment": "Window functions",
					"match": "(?i)(?<!\\.)\\b(row_number|rank|lag|lead)\\b"
				}
			]
		},
		"illegal-names": {
			"match": "(?i)\\b(and|or|not|in|is|def|where|else|for|from|if|as|import|select|persist|merge|datasource|key|metric|property|const|auto)\\b",
			"captures": {
				"1": {
					"name": "keyword.control.flow.trilogy"
				}
			}
		},
		"magic-names": {
			"patterns": [
				{
					"include": "#magic-function-names"
				},
				{
					"include": "#magic-variable-names"
				}
			]
		},
		"magic-function-names": {
			"comment": "these methods have magic interpretation by trilogy and are generally called\nindirectly through syntactic constructs\n",
			"match": "(?x)\n  \\b(\n    __(?:\n   select |  abs | add  | where | bool | ceil | cmp | coerce | contains | substr  |  delete |  div | divmod | eq\n| float | floor | floordiv | format | ge\n      |  gt\n      | hash | idiv | ifloordiv |\n     | ilshift | imod | imul | index  | ipow\n      | irshift | isub | iter | itruediv | ixor | le\n      | len | long | lshift | lt | missing | mod | mul\n      | ne | neg | new | next | nonzero | oct | or | pos\n      | pow | radd | rand | rdiv | rdivmod | reduce\n      | reduce_ex | repr | reversed | rfloordiv | rlshift | rmod | rmul | ror | round | rpow\n  | rtruediv | rxor | set\n | str | sub   | truediv | trunc | fspath | bytes | prepare | length_hint\n    )__\n  )\\b\n",
			"captures": {
				"1": {
					"name": "support.function.magic.trilogy"
				}
			}
		},
		"magic-variable-names": {
			"comment": "magic variables which a class/module may have.",
			"match": "(?x)\n  \\b(\n    __(?:\n      all | annotations | where | bases | builtins | datasource\n | func\n    | address    | grain    )__\n  )\\b\n",
			"captures": {
				"1": {
					"name": "support.variable.magic.trilogy"
				}
			}
		},
		"function-call": {
			"name": "meta.function-call.trilogy",
			"comment": "Regular function call of the type \"name(args)\"",
			"begin": "(?x)\n  \\b(?=\n    ([[:alpha:]_]\\w*) \\s* (\\()\n  )\n",
			"end": "(\\))",
			"endCaptures": {
				"1": {
					"name": "punctuation.definition.arguments.end.trilogy"
				}
			},
			"patterns": [
				{
					"include": "#function-name"
				},
				{
					"include": "#function-arguments"
				}
			]
		},
		"function-arguments": {
			"begin": "(\\()",
			"end": "(?=\\))(?!\\)\\s*\\()",
			"beginCaptures": {
				"1": {
					"name": "punctuation.definition.arguments.begin.trilogy"
				}
			},
			"contentName": "meta.function-call.arguments.trilogy",
			"patterns": [
				{
					"name": "punctuation.separator.arguments.trilogy",
					"match": "(,)"
				},
				{
					"match": "(?x)\n  (?:(?<=[,(])|^) \\s* (\\*{1,2})\n",
					"captures": {
						"1": {
							"name": "keyword.operator.unpacking.arguments.trilogy"
						}
					}
				},
				{
					"include": "#illegal-names"
				},
				{
					"match": "\\b([[:alpha:]_]\\w*)\\s*(=)(?!=)",
					"captures": {
						"1": {
							"name": "variable.parameter.function-call.trilogy"
						},
						"2": {
							"name": "keyword.operator.assignment.trilogy"
						}
					}
				},
				{
					"name": "keyword.operator.assignment.trilogy",
					"match": "=(?!=)"
				},
				{
					"include": "#expression"
				},
				{
					"match": "\\s*(\\))\\s*(\\()",
					"captures": {
						"1": {
							"name": "punctuation.definition.arguments.end.trilogy"
						},
						"2": {
							"name": "punctuation.definition.arguments.begin.trilogy"
						}
					}
				}
			]
		},
		"expression-base": {
			"comment": "valid trilogy expressions with comments and line continuation",
			"patterns": [
				{
					"include": "#comments"
				},
				{
					"include": "#expression-bare"
				},
				{
					"include": "#line-continuation"
				}
			]
		},
		"list": {
			"begin": "\\[",
			"end": "\\]",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.list.begin.trilogy"
				}
			},
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.list.end.trilogy"
				}
			},
			"patterns": [
				{
					"include": "#expression"
				}
			]
		},
		"concept-list": {
			"begin": "<",
			"end": ">",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.list.begin.trilogy"
				}
			},
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.list.end.trilogy"
				}
			},
			"patterns": [
				{
					"include": "#function-def-name"
				}
			]
		},
		"number-float": {
			"name": "constant.numeric.float.trilogy",
			"match": "(?x)\n  (?<! \\w)(?:\n    (?:\n      \\.[0-9](?: _?[0-9] )*\n      |\n      [0-9](?: _?[0-9] )* \\. [0-9](?: _?[0-9] )*\n      |\n      [0-9](?: _?[0-9] )* \\.\n    ) (?: [eE][+-]?[0-9](?: _?[0-9] )* )?\n    |\n    [0-9](?: _?[0-9] )* (?: [eE][+-]?[0-9](?: _?[0-9] )* )\n  )([jJ])?\\b\n",
			"captures": {
				"1": {
					"name": "storage.type.imaginary.number.trilogy"
				}
			}
		},
		"number-dec": {
			"name": "constant.numeric.dec.trilogy",
			"match": "(?x)\n  (?<![\\w\\.])(?:\n      [1-9](?: _?[0-9] )*\n      |\n      0+\n      |\n      [0-9](?: _?[0-9] )* ([jJ])\n      |\n      0 ([0-9]+)(?![eE\\.])\n  )\\b\n",
			"captures": {
				"1": {
					"name": "storage.type.imaginary.number.trilogy"
				},
				"2": {
					"name": "invalid.illegal.dec.trilogy"
				}
			}
		},
		"number": {
			"name": "constant.numeric.trilogy",
			"patterns": [
				{
					"include": "#number-float"
				},
				{
					"include": "#number-dec"
				},
				{
					"include": "#number-long"
				},
				{
					"name": "invalid.illegal.name.trilogy",
					"match": "\\b[0-9]+\\w+"
				}
			]
		},
		"number-long": {
			"name": "constant.numeric.bin.trilogy",
			"comment": "this is to support trilogy2 syntax for long ints",
			"match": "(?x)\n  (?<![\\w\\.])\n    ([1-9][0-9]* | 0) ([lL])\n  \\b\n",
			"captures": {
				"2": {
					"name": "storage.type.number.trilogy"
				}
			}
		},
		"literal": {
			"patterns": [
				{
					"name": "constant.language.trilogy",
					"match": "(?i)\\b(true|false|null)\\b"
				},
				{
					"include": "#number"
				}
			]
		},
		"illegal-operator": {
			"patterns": [
				{
					"name": "invalid.illegal.operator.trilogy",
					"match": "&&|\\|\\||--|\\+\\+"
				},
				{
					"name": "invalid.illegal.operator.trilogy",
					"match": "[?$]"
				},
				{
					"name": "invalid.illegal.operator.trilogy",
					"comment": "We don't want `!` to flash when we're typing `!=`",
					"match": "!\\b"
				}
			]
		},
		"operator": {
			"patterns": [
				{
					"name": "keyword.operator.logical.trilogy",
					"match": "(?i)\\b(and|or|not|in|is|between|like|ilike)\\b"
				},
				{
					"name": "keyword.operator.assignment.trilogy",
					"comment": "Arrow assignment operators",
					"match": "<-|->|::"
				},
				{
					"name": "keyword.operator.arithmetic.trilogy",
					"match": "\\*\\*|\\*|\\+|-|%|/|\\|\\|"
				},
				{
					"name": "keyword.operator.comparison.trilogy",
					"match": "!=|==|>=|<=|<>|<|>|="
				}
			]
		},
		"round-braces": {
			"begin": "\\(",
			"end": "\\)",
			"beginCaptures": {
				"0": {
					"name": "punctuation.parenthesis.begin.trilogy"
				}
			},
			"endCaptures": {
				"0": {
					"name": "punctuation.parenthesis.end.trilogy"
				}
			},
			"patterns": [
				{
					"include": "#expression"
				}
			]
		},
		"expression-bare": {
			"comment": "valid trilogy expressions w/o comments and line continuation",
			"patterns": [
				{
					"include": "#literal"
				},
				{
					"include": "#string"
				},
				{
					"include": "#lambda-transform"
				},
				{
					"include": "#hash-type"
				},
				{
					"include": "#date-part"
				},
				{
					"include": "#illegal-operator"
				},
				{
					"include": "#operator"
				},
				{
					"include": "#item-access"
				},
				{
					"include": "#list"
				},
				{
					"include": "#odd-function-call"
				},
				{
					"include": "#round-braces"
				},
				{
					"include": "#function-call"
				},
				{
					"include": "#builtin-functions"
				},
				{
					"include": "#builtin-types"
				},
				{
					"include": "#magic-names"
				},
				{
					"include": "#punctuation"
				},
				{
					"include": "#line-continuation"
				}
			]
		},
		"punctuation": {
			"patterns": [
				{
					"name": "punctuation.separator.colon.trilogy",
					"match": ":"
				},
				{
					"name": "punctuation.separator.element.trilogy",
					"match": ","
				}
			]
		},
		"lambda-transform": {
			"comment": "Lambda transform syntax @identifier used in array_transform and array_filter",
			"name": "variable.parameter.lambda.trilogy",
			"match": "@[[:alpha:]_][[:word:]]*"
		},
		"hash-type": {
			"comment": "Hash algorithm types",
			"name": "constant.other.hash-type.trilogy",
			"match": "(?i)\\b(md5|sha1|sha256|sha512)\\b"
		},
		"date-part": {
			"comment": "Date part constants used in date functions",
			"name": "constant.other.date-part.trilogy",
			"match": "(?i)\\b(DAY|WEEK|MONTH|QUARTER|YEAR|MINUTE|HOUR|SECOND|DAY_OF_WEEK)\\b"
		},
		"odd-function-call": {
			"comment": "A bit obscured function call where there may have been an\narbitrary number of other operations to get the function.\nE.g. \"arr[idx](args)\"\n",
			"begin": "(?x)\n  (?<= \\] | \\) ) \\s*\n  (?=\\()\n",
			"end": "(\\))",
			"endCaptures": {
				"1": {
					"name": "punctuation.definition.arguments.end.trilogy"
				}
			},
			"patterns": [
				{
					"include": "#function-arguments"
				}
			]
		},
		"line-continuation": {
			"patterns": [
				{
					"match": "(\\\\)\\s*(\\S.*$\\n?)",
					"captures": {
						"1": {
							"name": "punctuation.separator.continuation.line.trilogy"
						},
						"2": {
							"name": "invalid.illegal.line.continuation.trilogy"
						}
					}
				},
				{
					"begin": "(\\\\)\\s*$\\n?",
					"end": "(?x)\n  (?=^\\s*$)\n  |\n  (?! (\\s* [rR]? (\\'\\'\\'|\\\"\\\"\\\"|\\'|\\\"))\n      |\n      (\\G $)  (?# '\\G' is necessary for ST)\n  )\n",
					"beginCaptures": {
						"1": {
							"name": "punctuation.separator.continuation.line.trilogy"
						}
					},
					"patterns": [
						{
							"include": "#string"
						}
					]
				}
			]
		},
		"string": {
			"patterns": [
				{
					"include": "#string-quoted-multi-line"
				},
				{
					"include": "#string-quoted-single-line"
				}
			]
		},
		"string-quoted-multi-line": {
			"name": "string.quoted.multi.trilogy",
			"begin": "(?:\\b([rR])(?=[uU]))?([uU])?('''|\"\"\")",
			"end": "(\\3)",
			"beginCaptures": {
				"1": {
					"name": "invalid.illegal.prefix.trilogy"
				},
				"2": {
					"name": "storage.type.string.trilogy"
				},
				"3": {
					"name": "punctuation.definition.string.begin.trilogy"
				}
			},
			"endCaptures": {
				"1": {
					"name": "punctuation.definition.string.end.trilogy"
				},
				"2": {
					"name": "invalid.illegal.newline.trilogy"
				}
			},
			"patterns": [
				{
					"include": "#string-unicode-guts"
				}
			]
		},
		"string-quoted-single-line": {
			"name": "string.quoted.single.trilogy",
			"begin": "(?:\\b([rR])(?=[uU]))?([uU])?((['\"]))",
			"end": "(\\3)|((?<!\\\\)\\n)",
			"beginCaptures": {
				"1": {
					"name": "invalid.illegal.prefix.trilogy"
				},
				"2": {
					"name": "storage.type.string.trilogy"
				},
				"3": {
					"name": "punctuation.definition.string.begin.trilogy"
				}
			},
			"endCaptures": {
				"1": {
					"name": "punctuation.definition.string.end.trilogy"
				},
				"2": {
					"name": "invalid.illegal.newline.trilogy"
				}
			},
			"patterns": [
				{
					"include": "#string-unicode-guts"
				}
			]
		},
		"string-unicode-guts": {
			"patterns": [
				{
					"include": "#string-entity"
				}
			]
		},
		"string-entity": {
			"patterns": [
				{
					"include": "#string-line-continuation"
				}
			]
		},
		"string-line-continuation": {
			"name": "constant.language.trilogy",
			"match": "\\\\$"
		}
	},
	"scopeName": "source.trilogy"
}